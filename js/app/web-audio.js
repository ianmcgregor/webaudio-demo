/* web-audio.js */

define(
	[],
	function() {

		'use strict';

		function WebAudio(context) {
			this.context = context || this.createContext();
			this._sound = [];
			this._node = [];
			this._gain = this.context.createGain();
			this._gain.connect(this.context.destination);
			this._startedAt = 0;
			this._pausedAt = 0;
			this._loop = false;
			this._playing = false;
			this._nodeFactory = new WebAudio.NodeFactory(this.context);
		}

		WebAudio.prototype = {
			createContext: function() {
				var context = null;
				window.AudioContext = window.AudioContext || window.webkitAudioContext;
				if(window.AudioContext) {
					context = new window.AudioContext();
				}
				return context;
			},
			add: function(buffer) {
				this._sound.push(new WebAudio.Sound(buffer, this.context));
				return this._sound[this._sound.length-1];
			},
			play: function() {
				for (var i = 0; i < this._sound.length; i++) {
					this._sound[i].stop();
					this._sound[i].connect(this._gain);
					this._sound[i].play(0, this._pausedAt / 1000);
				}
				this._startedAt = Date.now() - this._pausedAt;
				this._playing = true;
			},
			pause: function() {
				this.stop();
				this._pausedAt = Date.now() - this._startedAt;
			},
			stop: function() {
				for (var i = 0; i < this._sound.length; i++) {
					this._sound[i].stop();
				}
				this._pausedAt = 0;
				this._playing = false;
			}
		};

		Object.defineProperty(WebAudio.prototype, 'loop', {
			get: function() {
				return this._loop;
			},
			set: function(value) {
				this._loop = value;
				for (var i = 0; i < this._sound.length; i++) {
					this._sound[i].loop = value;
				}
			}
		});

		Object.defineProperty(WebAudio.prototype, 'volume', {
			get: function() {
				return this._gain.gain.value;
			},
			set: function(value) {
				if(isNaN(value)) {
					return;
				}
				this._gain.gain.value = value;
			}
		});

		Object.defineProperty(WebAudio.prototype, 'playing', {
			get: function() {
				return this._playing;
			}
		});

		Object.defineProperty(WebAudio.prototype, 'sound', {
			get: function() {
				return this._sound;
			}
		});

		Object.defineProperty(WebAudio.prototype, 'nodeFactory', {
			get: function() {
				return this._nodeFactory;
			}
		});

		/*
		 * Sound
		 */

		WebAudio.Sound = function(buffer, context) {
			this._buffer = buffer;
			this._context = context;
			this._source = null;
			this._node = [];
			this._loop = false;
			this.name = '';
		};

		WebAudio.Sound.prototype = {
			play: function(delay, offset) {
				if(delay === undefined) {
					delay = 0;
				}
				else if(delay > 0) {
					delay = this._context.currentTime + delay;
				}
				if(offset === undefined) {
					offset = 0;
				}
				this.source.loop = this._loop;
				this.source.start(delay, offset);
			},
			stop: function() {
				if(this._source) {
					this._source.stop(0);
					this._source = null;
				}
			},
			connect: function(node) {
				if(this._node.length > 0) {
					this._node[this._node.length - 1].connect(node);
				}
				else {
					this.source.connect(node);
				}
				this.destination = node;
			},
			addNode: function(node) {
				this._node.push(node);
				this.updateConnections();
			},
			updateConnections: function() {
				if(!this._source) {
					return;
				}
				for (var i = 0; i < this._node.length; i++) {
					if(i === 0) {
						this._source.connect(this._node[i]);
					}
					else {
						this._node[i-1].connect(this._node[i]);
					}
				}
				if(this.destination) {
					this.connect(this.destination);
				}
			}
		};

		Object.defineProperty(WebAudio.Sound.prototype, 'source', {
			get: function() {
				if(!this._source) {
					this._source = this._context.createBufferSource();
					this._source.buffer = this._buffer;
					this.updateConnections();
				}
				return this._source;
			}
		});

		Object.defineProperty(WebAudio.Sound.prototype, 'loop', {
			get: function() {
				return this._loop;
			},
			set: function(value) {
				this._loop = value;
			}
		});

		/*
		 * Nodes
		 */

		WebAudio.NodeFactory = function(context) {

			function createFilter(type, frequency) {
				var filterNode = context.createBiquadFilter();
				filterNode.type = type;
				if(frequency !== undefined) {
					filterNode.frequency.value = frequency;
				}
				return filterNode;
			}

			function setOptionalParam(value, defaultValue) {
				if(value === undefined) {
					value = defaultValue;
				}
				return value;
			}

			return {
				gain: function(value) {
					var node = context.createGain();
					if(value !== undefined) {
						node.gain.value = value;
					}
					return node;
				},
				pan: function(x, y, z) {
					var node = context.createPanner();
					setOptionalParam(x, 0);
					setOptionalParam(y, 0);
					setOptionalParam(z, 0.5);
					node.setPosition(x, y, z);
					return node;
				},
				filter: {
					lowpass: function(frequency) {
						return createFilter('lowpass', frequency);
					},
					highpass: function(frequency) {
						return createFilter('highpass', frequency);
					},
					bandpass: function(frequency) {
						return createFilter('bandpass', frequency);
					},
					lowshelf: function(frequency) {
						return createFilter('lowshelf', frequency);
					},
					highshelf: function(frequency) {
						return createFilter('highshelf', frequency);
					},
					peaking: function(frequency) {
						return createFilter('peaking', frequency);
					},
					notch: function(frequency) {
						return createFilter('notch', frequency);
					},
					allpass: function(frequency) {
						return createFilter('allpass', frequency);
					}
				},
				delay: function(time) {
					var node = context.createDelay();
					if(time !== undefined) {
						node.delayTime = time;
					}
					return node;
				},
				convolver: function() {
					var node = context.createConvolver();
					return node;
				},
				analyser: function() {
					var node = context.createAnalyser();
					node.smoothingTimeConstant = 0.85;
					return node;
				}
			};
		};

		/*
		 * Effects
		 */

		WebAudio.Effects = function(context) {

			function ramp(param, value, duration) {
				param.linearRampToValueAtTime(value, context.currentTime + duration);
			}

			return {
				fade: function(gainNode, value, duration) {
					ramp(gainNode.gain, value, duration);
				}
			};
		};

		return WebAudio;
	}
);